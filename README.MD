# An√°lise de Teste de Caixa Branca - Autentica√ß√£o de Usu√°rio

Este reposit√≥rio documenta a an√°lise est√°tica e estrutural de uma classe Java (`User.java`), aplicando os conceitos de teste de caixa branca para identificar vulnerabilidades e definir uma estrat√©gia de teste de ciclo.

## Estrutura do Reposit√≥rio

---

## 1. üìã An√°lise Est√°tica (Inspe√ß√£o de C√≥digo)

A primeira fase foi uma inspe√ß√£o manual do c√≥digo-fonte original (`codigoOriginal/User.java`). O objetivo foi encontrar "code smells", vulnerabilidades e m√°s pr√°ticas de design.

**Principais Falhas Identificadas:**
* **Risco de NullPointerException:** O m√©todo `conectarBD` retorna `null` em caso de falha, mas esse retorno n√£o √© validado antes de ser usado (`conn.createStatement()`).
* **Vazamento de Recursos:** Os objetos `Connection`, `Statement` e `ResultSet` n√£o s√£o fechados (`.close()`), o que esgotaria o pool de conex√µes do banco de dados.
* **Viola√ß√£o de Arquitetura:** A classe de entidade `User` est√° incorretamente gerenciando a conex√£o com o BD, ferindo o princ√≠pio da Separa√ß√£o de Camadas.

### Planilha de Inspe√ß√£o

A imagem abaixo (de `planilha/palnilha.JPG`) detalha os 7 pontos de falha encontrados durante a inspe√ß√£o:

![Planilha de An√°lise Est√°tica](planilha/planilha.JPG)

*(O arquivo-fonte desta planilha pode ser encontrado em: `planilha/ui_ux.xlsx`)*

---

## 2. üî¨ An√°lise Estrutural (Teste de Ciclo)

Nesta etapa, decompomos o m√©todo `verificarUsuario()` em um grafo visual para analisar sua l√≥gica interna e calcular o n√∫mero de testes necess√°rios.

### 2.1. Grafo de Fluxo de Controle

Para diferenciar da an√°lise padr√£o, foi gerado um grafo vertical (`TD`) com nomes de n√≥s descritivos (A√ß√£o/Decis√£o) em vez de n√∫meros.

### 2.2. C√°lculo da Complexidade Ciclom√°tica (V(G))

A Complexidade Ciclom√°tica (V(G)) define o n√∫mero de caminhos independentes. Usamos a f√≥rmula baseada em Arestas (E) e N√≥s (N):

$$ V(G) = E - N + 2 $$

Onde, para o nosso grafo acima:
* **N (N√≥s):** 6 (A√ß√£o 1, Decis√£o A, Decis√£o B, A√ß√£o 2, A√ß√£o 3, A√ß√£o 4)
* **E (Arestas):** 7 (As 7 setas que ligam os n√≥s)

**C√°lculo:**
$$ V(G) = 7 - 6 + 2 = 3 $$

Um V(G) de **3** indica que s√£o necess√°rios **3 Caminhos B√°sicos** (ou 3 testes) para cobrir 100% da l√≥gica do m√©todo.

### 2.3. Caminhos B√°sicos (com Destaque Visual)

Com base no V(G)=3, a imagem abaixo (exportada do `draw.io`) mostra os tr√™s caminhos de teste independentes, cada um com um destaque de cor:

![Caminhos B√°sicos Destacados](fluxos/cicloB√°sico.drawio%20o.png)


**Caminhos B√°sicos (Rotas):**

```
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7(true) -> 8 -> 12
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7(false) -> 9 -> 12
1 -> 2 -> 3 -> 4(catch) -> 10 -> 11(finaliza)
```

**C√°lculo (F√≥rmula `E - N + 2P`):**

```
M = E - N + 2P
M = 13 - 12 + 2x1
M = 1 + 2
M = 3
```

**Vari√°veis do C√°lculo (Corrigido):**

```
N = 12 n√≥s (blocos)

E = 13 arestas (setas)

P = 1 (m√©todo)
```

---
## 3. üß™ Teste Pr√°tico & Prova de Falha (C√≥digo Original)

Para validar a an√°lise te√≥rica, foi executado um teste pr√°tico no `codigoOriginal/User.java` (adicionando um m√©todo `main` para for√ßar os 3 caminhos).

### 3.1. Resultados Observados

O teste pr√°tico exp√¥s uma falha cr√≠tica: **todos os 3 caminhos retornaram `false`**, incluindo o "Caminho Feliz" (Teste 1), que deveria retornar `true`.

![Print do Terminal mostrando Teste 1, 2 e 3 retornando 'false'](evidenciasTeste/TesteCodigoOriginal.JPG)

### 3.2. Diagn√≥stico da Falha

O resultado acima prova que a execu√ß√£o do c√≥digo **nunca** alcan√ßa o `if(rs.next())` (N√≥ 7). A falha ocorre antes.

O facto de o Teste 1 (BD ligado) e o Teste 3 (BD desligado) darem o mesmo resultado (`false`) prova que a aplica√ß√£o est√° sempre a executar o caminho de exce√ß√£o (Caminho 3).

Esta observa√ß√£o valida 100% as falhas encontradas na An√°lise Est√°tica (Planilha):
1.  O m√©todo `conectarBD()` falha ao tentar se conectar (ex: erro de autentica√ß√£o com a senha `123456`).
2.  A falha cai no `catch (Exception e) {}` do `conectarBD`, que por estar **vazio**, "engole" o erro e retorna `null`.
3.  No `verificarUsuario()`, a vari√°vel `conn` recebe `null`.
4.  O c√≥digo tenta executar `conn.createStatement()`, o que causa um **`NullPointerException`** (previsto na planilha).
5.  Esse `NPE` cai no `catch (Exception e) {}` do `verificarUsuario()`, que tamb√©m est√° **vazio**.
6.  O m√©todo termina e retorna `false`.

> **Conclus√£o:** O teste pr√°tico no `codigoOriginal` validou com sucesso a an√°lise est√°tica, provando que os blocos `catch` vazios e a falta de tratamento de `null` s√£o a causa raiz da falha total do m√©todo.

*(Opcional: Um print do erro real, `NullPointerException`, pode ser adicionado aqui se o `catch` fosse preenchido apenas para depura√ß√£o).*

![Print do Terminal mostrando os erros reais (PSQLException e NullPointerException)](evidenciasTeste/teste.JPG)

---

## 4. üõ†Ô∏è C√≥digos-Fonte

* **[Vers√£o Original](vers√£oOriginal/User.java)**: O c√≥digo-fonte defeituoso que foi alvo desta an√°lise e teste.
* **[Vers√£o Corrigida](Vers√£oCorrigida/User.java)**: O c√≥digo refatorado, que usa `try-with-resources` e `PreparedStatement`.# Atividade-Individual-Caixa-Branca-248932--Gabriella-Iglesias
